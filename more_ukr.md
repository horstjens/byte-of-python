# Більше 

Наразі ми розглянули більшість різноманітних аспектів Python, які ви використовуватимете. У цьому розділі ми розглянемо ще деякі аспекти, які зроблять наші знання про Python більш повними.

## Передача кортежів
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _Passing tuples around_ 

Ви коли-небудь хотіли, щоб функція повернула не один результат, а два? Це
можливо. Все, що для цього потрібно, – використовувати кортеж.

:::::{tab-set}
::::{tab-item} українська
**код python** (idle) 
```python
>>> def отримати_опис_помилки():
...     return (2,"опис")
... 
>>> номер_помилки,рядок_помилки = отримати_опис_помилки()
>>> номер_помилки
2
>>> рядок_помилки
'опис'
```
::::
::::{tab-item} англійська
**python code** (idle)
```python
>>> def get_error_details():
...     return (2, 'details')
...
>>> errnum, errstr = get_error_details()
>>> errnum
2
>>> errstr
'details'
```
::::
:::::




Зауважте, що використання `a, b = <деякий вираз>` (англ." `a, b = <some expression>`") інтерпретує результат виразу як кортеж із двома значеннями.

Це також означає, що найшвидший спосіб поміняти дві змінні в Python можна наступним чином:

```python
>>> a = 5; b = 8
>>> a, b
(5, 8)
>>> a, b = b, a
>>> a, b
(8, 5)
```

## Спеціальні методи

Існують певні методи, такі як `__init__` і `__del__`, які мають особливе значення в класах.

Для імітації певної поведінки вбудованих типів даних використовуються спеціальні методи. Наприклад, якщо ви хочете використовувати операцію індексування `x[індекс]` (англ. `x[key]`) для свого класу (так само, як ви використовуєте її для списків і кортежів), тоді все, що вам потрібно зробити, це реалізувати метод `__getitem__()` і ваше завдання зроблено. До речі, саме цей метод Python використовує для класу`list`!

Деякі корисні спеціальні методи перераховані в наступній таблиці. Якщо ви хочете дізнатися про всі спеціальні методи, [перегляньте посібник](http://docs.python.org/3/reference/datamodel.html#special-method-names). 

- `__init__(self, ...)`
  - Цей метод викликається безпосередньо перед тим, як новостворений об’єкт повертається для використання.

- `__del__(self)`
    - Викликається безпосередньо перед знищенням об’єкта (що має непередбачуваний час, тому уникайте цього)

- `__str__(self)`
    - Викликається, коли ми використовуємо функцію `print` або `str()`.

- `__lt__(self, other)`
    - Викликається, коли використовується оператор _менше ніж_ (<). Так само існують спеціальні методи для всіх операторів (+, > тощо)

- `__getitem__(self, key)`
    - Викликається, коли використовується операція індексування `x[індекс]`.

- `__len__(self)`
    - Викликається, коли для об’єкта послідовності використовується вбудована функція `len()`.

## Блоки окремих операторів Блоки в один вираз
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _Single Statement Blocks_ 

Ми бачили, що кожен блок рядків коду відокремлений від решти власним рівнем відступу. Що ж, є одне застереження. Якщо ваш блок рядків коду містить лише один вираз, ви можете вказати його в одному рядку, скажімо, умовного оператора або оператора циклу. Наступний приклад повинен прояснити це:

```python
>>> flag = True
>>> if flag: print('Yes')
...
Yes
```

Зверніть увагу, що єдиний оператор використовується в рядку, а не як окремий блок. Хоча ви можете використовувати це, щоб зробити свою програму _меншою_, я наполегливо рекомендую уникати цього скороченого методу, за винятком перевірки помилок, головним чином тому, що буде набагато легше додати додатковий оператор, якщо ви використовуєте належний відступ.

## Лямбда-форми
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _Lambda Forms_

Ключове слово `lambda` використовується для створення нових функціональних об’єктів (нових функцій та повернення їх значення у час виконання програми). По суті, "лямбда" приймає параметр, за яким слідує один вираз. Лямбда стає тілом функції. Значення цього виразу повертається новою функцією.


::::{admonition} **код python** [more_lambda_ukr.py](programs/more_lambda_ukr.py)
:::{literalinclude} programs/more_lambda_ukr.py
:::
**Висновок**:
:::{literalinclude} programs/more_lambda_ukr.txt
:::
::::


**Як це працює**

Зверніть увагу, що метод `sort` класа `list` може приймати параметр `key`, який визначає спосіб сортування списку (зазвичай ми думаємо тільки про сортування за зростанням або за спаданням). У нашому випадку ми хочемо виконати спеціальне сортування, і для цього нам потрібно написати функцію. Замість написання окремого блоку `def` для функції, яка використовуватиметься лише в цьому місці, ми використовуємо лямбда-вираз для створення нової функції.

## Генератори списків
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _List Comprehension_

Генератори списків використовується для отримання нового списку з існуючого списку. Уявіть, що є список чисел, на основі якого потрібно отримати новий список,
що складається з усіх чисел, помножених на 2, але тільки за умови, що саме число більше 2. Генератори списків ідеально підходить для таких ситуацій.

Приклад англійською (зберегти як `more_list_comprehension.py`):

::::{admonition} **код python** [more_list_comprehension_ukr.py](programs/more_list_comprehension_ukr.py)
:::{literalinclude} programs/more_list_comprehension_ukr.py
:::
**Висновок**:
:::{literalinclude} programs/more_list_comprehension_ukr.txt
:::
::::


**Як це працює**

Тут ми отримуємо новий список, вказуючи маніпуляцію, яку потрібно виконати (`2*i`), коли виконується певна умова (`if i > 2`). Зауважте, що вихідний список залишається без змін.

Перевага використання генераторів списків полягає в тому, що воно зменшує кількість шаблонного коду, необхідного, коли ми використовуємо цикли для обробки кожного елемента списку та збереження його в новому списку.

## Передача кортежів та словників у функції 
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _Receiving Tuples and Dictionaries in Functions_

Існує спеціальний спосіб для отримання параметрів переданих функції, у вигляді кортежу або словника за допомогою префікса `*` або `**` відповідно. Це корисно, коли функція приймає змінну кількість аргументів.

:::::{tab-set}
::::{tab-item} українська
**код python** (idle) 
```python
>>> def сума_зведення_у_ступінь(зведення_у_ступінь, *args):
...     '''Повертає суму кожного аргументу, зведеного до вказаного степеня.'''
...     результат = 0
...     for i in args:
...         результат += pow(i, зведення_у_ступінь)
...     return результат
... 
>>> сума_зведення_у_ступінь(2, 3, 4)
25
>>> сума_зведення_у_ступінь(2, 10)
100
```
::::
::::{tab-item} англійська
**python code** (idle)
```python
>>> def powersum(power, *args):
...     '''Return the sum of each argument raised to the specified power.'''
...     total = 0
...     for i in args:
...         total += pow(i, power)
...     return total
...
>>> powersum(2, 3, 4)
25
>>> powersum(2, 10)
100
```
::::
:::::



Оскільки ми маємо префікс `*` у змінній `args`, усі додаткові аргументи, передані функції, зберігаються в `args` як кортеж. Якби замість нього використовувався префікс `**`, додаткові параметри вважалися б парами ключ/значення словника.

## Інструкція assert
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _The assert statement_

Інструкція `assert` використовується для підтвердження того, чи є задана умова істинною чи ні. Якщо умова виконується, нічого не відбувається, але якщо вона не відповідає дійсності, інструкція `assert` є ідеальним у цій ситуації.
Коли задана умова хибна, виникає помилка AssertionError.
Метод `pop()` видаляє та повертає останній елемент зі списку.

:::::{tab-set}
::::{tab-item} українська
**код python** (idle) 
```python
>>> мій_лист=["елемент"]
>>> assert len(мій_лист) >= 1
>>> мій_лист.pop()
'елемент'
>>> assert len(мій_лист) >= 1
Traceback (most recent call last):
  File "/usr/lib/python3.10/idlelib/run.py", line 578, in runcode
    exec(code, self.locals)
  File "<pyshell#4>", line 1, in <module>
AssertionError
```
::::
::::{tab-item} англійська
**python code** (idle)
```python
>>> mylist = ['item']
>>> assert len(mylist) >= 1
>>> mylist.pop()
'item'
>>> assert len(mylist) >= 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
```
::::
:::::


Інструкцію `assert` слід використовувати з обережністю. У більшості випадків краще перехоплювати винятки або вирішувати відповідну проблему автоматично, або відображати повідомлення про помилку користувачеві, а потім вийти із програми.

## Декоратори
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _Decorators_  

Декоратори — це швидкий шлях до застосування функцій- обгорток (англ."wrapper functions"). Це функція, яка дозволяє обгортнути іншу функцію для розширення її функціональності без безпосередньої зміни коду.  «Обгорнути» функціональність тим самим кодом знову і знову- це корисно. Наприклад, я створив для себе "retry decorator", який я можу просто застосувати до будь-якої функції, і якщо під час запуску викидається(виникає) будь-який виняток, він повторюється ще раз, максимум 5 разів із затримкою між кожною повторною спробою. Це особливо корисно в ситуаціях, коли ви намагаєтеся здійснити  мережеве з’єднання з віддаленим комп’ютером:

::::{admonition} **код python** [decorators_en.py](programs/decorators_en.py)
:::{literalinclude} programs/decorators_en.py
:::
**Output**:
:::{literalinclude} programs/decorators_en.txt
::::

**Як це працює**

Подивитися:

- [Відео: Декоратори Python робляться легко (англ."Video : Python Decorators Made Easy")](https://youtu.be/MYAEv3JoenI) 
- http://www.ibm.com/developerworks/linux/library/l-cpdecor.html
- http://toumorokoshi.github.io/dry-principles-through-python-decorators.html

## Відмінності між Python 2 і Python 3

Подивитися:

- ["Шість" бібліотек (англ."Six" library")](http://pythonhosted.org/six/)
- [Перенесення на Python 3 Redux від Armin(англ."Porting to Python 3 Redux by Armin")](http://lucumr.pocoo.org/2013/5/21/porting-to-python-3-redux/)
- [Досвід Python 3 від PyDanny(англ."Python 3 experience by PyDanny")](http://pydanny.com/experiences-with-django-python3.html)
- [Офіційний посібник Django з портування на Python 3(англ."Official Django Guide to Porting to Python 3")](https://docs.djangoproject.com/en/dev/topics/python3/)
- [Обговорення на тему «Які переваги має python 3.x?» (англ."Discussion on What are the advantages to python 3.x?"](http://www.reddit.com/r/Python/comments/22ovb3/what_are_the_advantages_to_python_3x/)

## Резюме

У цій главі ми розглянули ще деякі функції Python, але не всі можливості Python. Однак на цьому етапі ми розглянули більшість того, що ви збираєтеся використовувати на практиці. Цього достатньо, щоб почати роботу з будь-якою програмою, яку ви збираєтеся створювати.

Далі ми обговоримо, як далі досліджувати Python.
