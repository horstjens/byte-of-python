# Функції 

Функції — є багаторазовими фрагментами програми. Вони дозволяють вам дати назву блоку рядків коду, щоб згодом запускати цей блок, використовуючи вказане ім’я будь-де у вашій програмі та будь-яку кількість разів. Це називається *викликом* функції. Ми вже використовували багато вбудованих функцій, таких як `len` і `range`.

Концепція функції є, ймовірно, *найважливішим* будівельним блоком будь-якого нетривіального програмного забезпечення (на будь-якій мові програмування), тому ми розглянемо різні аспекти функцій у цій главі.

Функції визначаються за допомогою ключового слова `def`. Для того, щоб створити функцію, потрібно розмістити ключове слово def перед ідентифікатором функції (її ім’ям), потім вказати пару дужок, всередині яких можуть міститися імена змінних, поставити в кінці рядка двокрапку, яка закінчує рядок. Далі йде блок рядків коду, які є частиною цієї функції. Приклад покаже, що це насправді дуже просто:


::::{admonition} код python '[function1_ukr.py](programs/function1_ukr.py)'
:::{literalinclude} programs/function1_ukr.py
:::
**Висновок**: 
:::{literalinclude} programs/function1_ukr.txt
:::
::::

**Як це працює**

Ми визначаємо функцію під назвою `скажи_привіт` використовуючи синтаксис, описаний вище. Ця функція не приймає параметрів і, отже, немає змінних, оголошених у дужках. Параметри функції – це деякі вхіднi дані, які ми можемо передати функції, щоб отримати відповідний їм результат.
Зверніть увагу, що ми можемо викликати ту саму функцію двічі, що означає, що нам не потрібно писати той самий код знову.

## Параметри функції

Функції можуть приймати параметри, тобто деякі значення, що передаються функції,щоб вона щось *зробила* з ними. Ці параметри схожі на змінні, за винятком того, що значення цих змінних вказуються при виклику функції, та під час роботи функції їм вже надано їх значення.

Параметри вказуються в парі круглих дужок при визначенні функції, розділені символом
коми. Коли ми викликаємо функцію, ми надаємо значення таким же чином. Зверніть увагу на термінологію: імена, наведені при визначенні функції, називаються *параметрами*, тоді як значення,які ви передаєте в функцію при її виклику, - називаються *аргументами*.

::::{admonition} код python '[function_param_ukr.py](programs/function_param_ukr.py)'
:::{literalinclude} programs/function_param_ukr.py
:::
**Висновок**: 
:::{literalinclude} programs/function_param_ukr.txt
:::
::::


**Як це працює**

Тут ми визначаємо функцію з назвою `print_max`, яка використовує два параметри з назвою `a` і `b`. Ми знаходимо більше число за допомогою простого  блоку  `if..else`, а потім друкуємо більше число.

Коли ми вперше викликаємо функцію `print_max`, ми безпосередньо передаємо числа як аргументи. У другому випадку ми викликаємо функцію зі змінними в якості аргументів. `print_max(x, y)` призначає значення аргумента `x` параметру `a`, а значення аргумента `y` - параметру `b`. Функція `print_max` працює однаково в обох випадках.

---- __Від перекладача__ ----

::::{admonition} код python '[function_param1_ukr.py](programs/function_param1_ukr.py)'
:::{literalinclude} programs/function_param1_ukr.py
:::
**Висновок**: 
:::{literalinclude} programs/function_param1_ukr.txt
:::
::::

де:
1. у рядку коду __def ноутбук (текст="привіт",кількість=2):__   , 
_текст_ та _кількість_ є параметрами;

2. у рядкях коду __ноутбук("Toshiba")__, __ноутбук("Lenovo", 8)__  , _Toshiba_, _Lenovo_, _8_  є аргументами.

--- __завершення прикладу від перекладача__ ---

## Локальні змінні

При оголошенні змінних всередині визначення функції, вони жодним чином не пов’язані з іншими змінними з такими ж іменами, які використовуються поза функцією, тобто імена змінних є *локальними* для функції. Це називається  *областю видимості* змінної. Область видимості всіх змінних обмежена блоком, де вони оголошені, починаючи з точки визначення імені.

::::{admonition} код python [function_local_ukr.py](programs/function_local_ukr.py)
:::{literalinclude} programs/function_local_ukr.py
:::
**Висновок**: 
:::{literalinclude} programs/function_local_ukr.txt
:::
::::


**Як це працює**

Коли ми вперше друкуємо *значення*, наданого імені *x*, у першому рядку тіла  функції (`print('x дорівнює', x)`), Python використовує значення параметра, оголошене в основному блоці над визначенням функції (x = 50).

Далі ми присвоюємо `x` значення `2`. Лише в межах функції `x` тепер має значення `2`. У глобальній області `x` все ще має значення `50`. Ім’я  `x` є локальним для нашої функції. Отже, коли ми змінюємо значення `x` у функції, `x` визначене в основному блоці, залишається незмінним.

За допомогою останнього виклика функції `print` , ми відображаємо значення  `x`, яке  вказане в основному блоці, тим самим підтверджуючи, що воно не змінилося при локальному привласненні значення раніше викликаної функції.

## `Global` оператор
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _The `global` statement_

Щоб призначити деяке значення змінній, визначеній на вищому рівні програми (тобто не в якійсь області видимості, як функції або класи), необхідно повідомити Python, що ії ім’я не є локальним, а є `глобальним`. Ми робимо це за допомогою оператора `global`. Неможливо призначити значення змінній, визначеній поза функцією, без оператора `global`.

Можна використовувати вже існуючі значення змінних, визначених поза межами функції (за умови, що всередині функції не було оголошено змінної з таким жe ім'ям).
Однак це не заохочується, і цього слід уникати, оскільки читачеві програми стає незрозуміло, де знаходиться визначення цієї змінної. Використання оператора `global` дає зрозуміти, що змінна визначена в самому зовнішньому блоці.



::::{admonition} код python [function_global_ukr.py](programs/function_global_ukr.py)
:::{literalinclude} programs/function_global_ukr.py
:::
**Висновок**: 
:::{literalinclude} programs/function_global_ukr.txt
:::
::::

**Як це працює**

Оператор `global` використовується для оголошення того, що `x` є глобальною змінною, отже, коли ми присвоюємо значення `x` всередині функції, це переінакшення позначиться на значенні змінної x в
основному блоці програми.

Ви можете вказати більше однієї глобальної змінної за допомогою того самого оператора `global`, наприклад: `global x, y, z`.

## Значення аргументів за замовчуванням
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _Default Argument Values_

Для деяких функцій ви можете зробити деякі параметри *необов’язковими* та використовувати значення за замовчуванням на випадок, якщо користувач не хоче надавати для них значення. Це робиться за допомогою значень аргументів за замовчуванням. Ви можете вказати значення аргументів за замовчуванням, додавши до назви параметра у визначенні функції оператор присвоєння (`=`), для подальших значень за замовчуванням.

Зауважте, що значення аргументу за замовчуванням має бути константою. Точніше, значення аргументу за замовчуванням має бути незмінним (англ."immutable")- це детально пояснюється в наступних розділах. Наразі просто запам’ятайте це.

::::{admonition} код python [function_default_ukr.py](programs/function_default_ukr.py)
:::{literalinclude} programs/function_default_ukr.py
:::
**Висновок**: 
:::{literalinclude} programs/function_default_ukr.txt
:::
::::

# Як це працює

Функція під назвою `висловлювання` використовується для друку рядка стільки разів, скільки вказано. Якщо ми не надаємо значення, то за замовчуванням рядок друкується лише один раз. Ми досягаємо цього, вказуючи значення аргументу за замовчуванням `1` для параметра `кількість`.

Під час першого виклика функції `висловлювання` ми вказуємо лише рядок ('Привіт'), і він друкує рядок один раз. Під час другого виклика функції `висловлювання` ми вказуємо і рядок('Привіт'), і аргумент `5`, вказуючи, що ми хочемо *промовити* повідомлення рядка 5 разів.

:::{admonition} *Важливо*
:class: Important
Значення за замовчуванням  можуть мати лише параметри, що знаходяться в кінці списку параметрів.
Таким чином, у списку параметрів функції, параметр зі значенням за замовчуванням не може передувати параметру без
значення за замовчуванням.
 
Це пов’язано з тим, що значення призначаються параметрам за позицією. Наприклад, `def func(a,
b=5)` є дійсним, але `def func(a=5, b)` є *недійсним*.
:::

##  Аргументи ключових слів
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _Keyword Arguments_

Якщо у вас є функції з багатьма параметрами, і ви хочете вказати при виклику функції лише деякі з них, тоді ви можете надати значення таким параметрам, назвавши їх - це називається *аргументи ключового слова*. У цьому випадку  для передачі аргументів функції використовується ім'я (ключ) замість позиції (як було досі).

Є дві переваги такого підходу: одна полягає в тому, що використовувати функцію легше, оскільки нам не потрібно турбуватися про порядок аргументів. По-друге, ми можемо надавати значення лише тим параметрам, яким ми хочемо, за умови, що інші параметри мають значення аргументів за замовчуванням.

::::{admonition} код python [function_keyword_ukr.py](programs/function_keyword_ukr.py)
:::{literalinclude} programs/function_keyword_ukr.py
:::
**Висновок**: 
:::{literalinclude} programs/function_keyword_ukr.txt
:::
::::

**Як це працює**

Функція з назвою `func` має один параметр без значення за замовчуванням, а потім два параметри зі значеннями за замовчуванням.

Під час першого виклику, `func(3, 7)`, параметр `a` отримує значення `3`, параметр `b` отримує значення `7`, а `c` отримує значення за умовчанням `10`.

При другому виклику `func(25, c=24)` змінна `a` отримує значення 25 через позицію аргументу. Тоді параметр `c` отримує значення `24` завдяки іменуванню, тобто ключовим аргументам. Змінна "b" отримує  значення  за замовчуванням, рівне "5".

У третьому випадку використання `func(c=50, a=100)` ми використовуємо ключові аргументи для всіх вказаних значень. Зверніть увагу, що ми вказуємо значення для параметра `c` перед значенням `a`, хоча `a` визначено перед `c` у визначенні функції.

## Довільна кількість аргументів
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _VarArgs parameters or variable number of arguments_

Іноді може виникнути потреба визначити функцію, яка може приймати _будь-яку_ кількість параметрів, тобто **змінну** кількість **аргументів**, цього можна досягти за допомогою зірочок (збережіть як `function_varargs.py`):



::::{admonition} код python [function_varargs_ukr.py](programs/function_varargs_ukr.py):
:::{literalinclude} programs/function_varargs_ukr.py
:::
**Висновок**:
:::{literalinclude} programs/function_varargs_ukr.txt
:::
::::


**Як це працює**

Коли ми оголошуємо параметр із зірочкою, наприклад `*param`, тоді всі позиційні аргументи від цієї позиції і до кінця збираються в кортеж під назвою 'param'.

Подібним чином, коли ми оголошуємо параметр із подвійною зірочкою, наприклад `**param`, тоді всі аргументи ключового слова від цієї позиції і до кінця збираються як словник під назвою 'param'.

Ми досліджуватимемо кортежі та словники в [пізнішій главі](./data_structures_ukr.md#data-structures).


## Оператор "return"
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _the `return` statement_

Оператор `return` використовується для *повернення* з функції, тобто для припинення її роботи та виходу з неї. За бажання ми також можемо *повернути значення* з функції.

::::{admonition} код python [function_return_ukr.py](programs/function_return_ukr.py)
:::{literalinclude} programs/function_return_ukr.py
:::
**Висновок**:
:::{literalinclude} programs/function_return_ukr.txt
:::
::::

**Як це працює**

Функція `максимум` повертає максимальний з двох параметрів, які в
даному випадку передаються їй під час виклику. Вона  використовує блок if...else для визначення найбільшого числа, а потім *повертає*  це число.

Зауважте, що оператор `return` без значення еквівалентний виразу `return None`. `None` — це спеціальний тип даних у Python, який представляє ніщо. Наприклад, він використовується, щоб вказати, що змінна не має значення, якщо вона дорівнює «None».

Кожна функція неявно містить оператор `return None` в кінці, якщо ви не написали власний оператор `return`. Ви можете побачити це, запустивши `print(some_function())`, де функція `some_function` не використовує оператор `return` у явному вигляді, наприклад:

```python
def some_function():
    pass
```

Оператор `pass` використовується в Python для позначення порожнього блоку команд.

:::{tip}
Існує вбудована функція під назвою `max`, яка вже реалізує функцію 'знайти максимум', тому використовуйте цю вбудовану функцію, коли це можливо.
:::


## Рядки документації
![uk-flag](img/brit_flag.png){w=40px}{bdg-secondary-line}`англійська:` _DocStrings_

У Python є чудова функція під назвою *рядки документації*, яку зазвичай називають коротшою назвою *DocStrings*. DocStrings є важливим інструментом, який вам слід використовувати, оскільки він допомагає краще документувати програму та полегшує її розуміння. Дивовижно, але ми навіть можемо отримати рядок документації, скажімо, з функції, коли програма фактично запущена!

::::{admonition} код python [function_docstring_ukr.py](programs/function_docstring_ukr.py)
:::{literalinclude} programs/function_docstring_ukr.py
:::
**Висновок**:
:::{literalinclude} programs/function_docstring_ukr.txt
:::
::::

**Як це працює**

Рядок у першому логічному рядку функції є *рядком документації* для цієї функції. Зверніть увагу, що DocStrings також застосовуються до [модулів](./modules_ukr.md#modules) та [класів](./oop_ukr.md#oop), про які ми дізнаємося у відповідних розділах.

Загальноприйнятим стилем написання docstring є багаторядковий рядок, у якому:
перший рядок починається з великої літери та закінчується крапкою,
другий рядок — порожній,
з третього рядка починається детальніше пояснення (за потреби).
*Hастійно рекомендовано* дотримуватися цього стилю для всіх ваших рядків документації зі всіма вашими нетривіальними функціями.

Ми можемо отримати доступ до рядка документації функції `print_max` за допомогою атрибута цієї функції (тобто імені, що належить їй) `__doc__` (зверніть увагу на *подвійне підкреслення*). Просто пам’ятайте, що Python розглядає *все* як об’єкт, включаючи функції. Ми дізнаємося більше про об’єкти в розділі про [класи](./oop_ukr.md#oop).

Якщо ви використовували функцію `help()` в Python, то ви вже бачили використання рядків документації! Ця функція просто зчитує атрибут `__doc__` відповідній функції та акуратно виводить його на екран.Ви можете перевірити її на розглянутій
вище функції: просто включить `help(print_max)` у текст програми. Не забудьте натиснути клавішу `q`, щоб вийти з `довідки`.

Так само автоматизовані інструменти можуть отримувати документацію з вашої програми. Тому я *настійно рекомендую* використовувати рядки документів для будь-якої нетривіальної функції, яку ви пишете. Команда `pydoc`, яка постачається з пакетом Python, працює подібно до `help()`, використовуючи рядки документації.

Приклад для "автоматизованих інструментів" від перекладача:

Редактор коду «Visual Studio Code» може зрозуміти, що таке рядок документації функції (рядок 2), і відобразити його в маленькому полі над курсором, коли ім’я функції вводиться (рядок 8).
Дивиться знімок екрана нижче:
 
:::{figure} img/docstring.png
:figwidth: 100 %

<sub>Знімок екрана коду Visual Studio, що відображає рядок документації</sub>
:::


## Резюме

Ми розглянули доволі багато аспектів функцій, але зауважте, що ми ще не охопили всі їх аспекти. Однак ми вже розглянули більшість того, що ви будете використовувати щодо функцій Python щодня.

Далі ми побачимо, як використовувати та створювати модулі Python.
